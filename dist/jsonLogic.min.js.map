{"version":3,"file":"jsonLogic.min.js","sources":["../src/createJsonLogicApply.js","../src/createJsonLogic.js","../src/index.js","../src/operations/arithmetic/add.js","../src/operations/array/filter.js","../src/operations/array/map.js","../src/operations/array/merge.js","../src/operations/arithmetic/multiply.js","../src/operations/array/reduce.js","../src/helpers/uses_data.js","../src/helpers/arrayUnique.js"],"sourcesContent":["import isArray from './helpers/isArray';\nimport is_logic from './helpers/is_logic';\nimport get_operator from './helpers/get_operator';\n\nexport default operators =>\n  function apply(logic, data) {\n    if (!data) data = {}; // eslint-disable-line no-param-reassign\n\n    // Does this array contain logic? Only one way to find out.\n    if (isArray(logic)) {\n      return logic.map(l => apply(l, data));\n    }\n    // You've recursed to a primitive, stop!\n    if (!is_logic(logic)) {\n      return logic;\n    }\n\n    const op_name = get_operator(logic);\n    let args = logic[op_name]; // operands\n\n    // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n    if (!isArray(args)) {\n      args = [args];\n    }\n\n    const operator = operators[op_name];\n    if (!operator) {\n      throw new Error(`Unrecognized operation ${op_name}`);\n    }\n\n    return operator(apply, data, args);\n  };\n","import isArray from './helpers/isArray';\nimport createJsonLogicApply from './createJsonLogicApply';\n\nfunction createJsonLogic(_operations, isRawOps) {\n  const operations = {};\n\n  if (_operations) {\n    Object.keys(_operations).forEach(name => {\n      const operation = _operations[name];\n\n      add_operation(operation.op || name, operation, isRawOps);\n    });\n  }\n\n  function add_operation(name, op, raw) {\n    if (isArray(name)) {\n      name.forEach(key => add_operation(key, op));\n      return;\n    }\n\n    if (typeof op === 'function') {\n      // handle `deepFirst`, `withApply`, `op` properties for compatibility\n      // with @axa-ch/json-logic-js:\n\n      if (raw || op.deepFirst === false) {\n        operations[name] = op;\n      } else if (op.withApply) {\n        operations[name] = (apply, data, raw_args) => {\n          const args = apply(raw_args, data);\n          return op(apply, ...args);\n        };\n      } else {\n        operations[name] = (apply, data, raw_args) => {\n          const args = apply(raw_args, data);\n          return op(...args);\n        };\n      }\n    } else if (typeof op === 'object') {\n      Object.getOwnPropertyNames(op).forEach(prop_name => {\n        add_operation(`${name}.${prop_name}`, op[prop_name]);\n      });\n    }\n  }\n\n  function rm_operation(name) {\n    if (isArray(name)) {\n      name.forEach(key => rm_operation(key));\n      return;\n    }\n\n    delete operations[name];\n  }\n\n  return {\n    apply: createJsonLogicApply(operations),\n    add_operation,\n    rm_operation,\n  };\n}\n\nexport default createJsonLogic;\n","import createJsonLogic from './createJsonLogic';\n\nimport is_logic from './helpers/is_logic';\nimport truthy from './helpers/truthy';\nimport get_operator from './helpers/get_operator';\nimport get_values from './helpers/get_values';\nimport uses_data from './helpers/uses_data';\nimport rule_like from './helpers/rule_like';\n\nimport * as op from './operations';\n\n// export original public API:\nexport default {\n  ...createJsonLogic(\n    {\n      /* eslint-disable */\n    '+': op.add,\n    'all': op.all,\n    'and': op.and,\n    'cat': op.cat,\n    '/': op.divide,\n    '==': op.equal,\n    'filter': op.filter,\n    '>': op.greater,\n    '>=': op.greaterEqual,\n    '?:': op.if,\n    'if': op.if,\n    'in': op.in,\n    '<': op.less,\n    '<=': op.lessEqual,\n    'log': op.log,\n    'map': op.map,\n    'max': op.max,\n    'merge': op.merge,\n    'method': op.method,\n    'min': op.min,\n    'missing': op.missing,\n    'missing_some': op.missing_some,\n    '%': op.modulo,\n    '*': op.multiply,\n    'none': op.none,\n    '!': op.not,\n    '!=': op.notEqual,\n    '!!': op.notnot,\n    'or': op.or,\n    'reduce': op.reduce,\n    'some': op.some,\n    '===': op.strictEqual,\n    '!==': op.strictNotEqual,\n    'substr': op.substr,\n    '-': op.subtract,\n    'var': op.var,\n    /* eslint-enable */\n    },\n    true\n  ),\n  is_logic,\n  truthy,\n  get_operator,\n  get_values,\n  uses_data,\n  rule_like,\n};\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);\n};\n","import isArray from '../../helpers/isArray';\nimport truthy from '../../helpers/truthy';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n  // Return only the elements from the array in the first argument,\n  // that return truthy when passed to the logic in the second argument.\n  // For parity with JavaScript, reindex the returned array\n  return scopedData.filter(datum => truthy(apply(scopedLogic, datum)));\n};\n","import isArray from '../../helpers/isArray';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n\n  return scopedData.map(datum => apply(scopedLogic, datum));\n};\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => a.concat(b), []);\n};\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => parseFloat(a) * parseFloat(b), 1);\n};\n","import isArray from '../../helpers/isArray';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n  const initial = typeof raw_args[2] !== 'undefined' ? raw_args[2] : null;\n\n  if (!isArray(scopedData)) {\n    return initial;\n  }\n\n  return scopedData.reduce(\n    (accumulator, current) => apply(scopedLogic, { current, accumulator }),\n    initial\n  );\n};\n","import isArray from './isArray';\nimport is_logic from './is_logic';\nimport get_operator from './get_operator';\nimport arrayUnique from './arrayUnique';\n\nfunction uses_data(logic) {\n  const collection = [];\n\n  if (is_logic(logic)) {\n    const op = get_operator(logic);\n    let values = logic[op];\n\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    if (op === 'var') {\n      // This doesn't cover the case where the arg to var is itself a rule.\n      collection.push(values[0]);\n    } else {\n      // Recursion!\n      values.forEach(val => {\n        collection.push(...uses_data(val));\n      });\n    }\n  }\n\n  return arrayUnique(collection);\n}\n\nexport default uses_data;\n","/**\n * Return an array that contains no duplicates (original not modified)\n * @param  {array} array   Original reference array\n * @return {array}         New array with no duplicates\n */\nfunction arrayUnique(array) {\n  const a = [];\n  for (let i = 0, l = array.length; i < l; i++) {\n    if (a.indexOf(array[i]) === -1) {\n      a.push(array[i]);\n    }\n  }\n  return a;\n}\n\nexport default arrayUnique;\n"],"names":["createJsonLogic","arrayUnique"],"mappings":"umBAUuB,CAAA,2yBCPvB,CAAA,wDAamB,CAAA,uRAsB0B,CAAA,gEA/BR,CAAA,+GAuClB,CAAA,yCCjCdA,CAAAA,2CCXgB,CAAA,6lBCWM,CAAA,oiBCHH,CAAA,4ICRH,CAAA,sYCAA,CAAA,yaCUjB,CAAA,umBCSiB,CAAA,2CChBrB,CAAA,4FDsBSC,CAAAA"}