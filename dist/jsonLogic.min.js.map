{"version":3,"file":"jsonLogic.min.js","sources":["../src/operators/add.js","../src/operators/filter.js","../src/operators/map.js","../src/operators/merge.js","../src/operators/multiply.js","../src/operators/reduce.js","../src/createJsonLogicApply.js","../src/index.js","../src/helpers/uses_data.js","../src/helpers/arrayUnique.js"],"sourcesContent":["export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);\n};\n","import isArray from '../helpers/isArray';\nimport truthy from '../helpers/truthy';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n  // Return only the elements from the array in the first argument,\n  // that return truthy when passed to the logic in the second argument.\n  // For parity with JavaScript, reindex the returned array\n  return scopedData.filter(datum => truthy(apply(scopedLogic, datum)));\n}\n","import isArray from '../helpers/isArray';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n\n  return scopedData.map(datum => apply(scopedLogic, datum));\n}\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => a.concat(b), []);\n}\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => parseFloat(a) * parseFloat(b), 1);\n}\n","import isArray from '../helpers/isArray';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n  const initial = typeof raw_args[2] !== 'undefined' ? raw_args[2] : null;\n\n  if (!isArray(scopedData)) {\n    return initial;\n  }\n\n  return scopedData.reduce(\n    (accumulator, current) => apply(scopedLogic, { current, accumulator }),\n    initial\n  );\n}\n","import isArray from './helpers/isArray';\nimport is_logic from './helpers/is_logic';\nimport get_operator_name from './helpers/get_operator_name';\n\nexport default (operators) => function apply(logic, data) {\n  if (!data) data = {};\n\n  // Does this array contain logic? Only one way to find out.\n  if (isArray(logic)) {\n    return logic.map(l => apply(l, data));\n  }\n  // You've recursed to a primitive, stop!\n  if (!is_logic(logic)) {\n    return logic;\n  }\n\n  const op_name = get_operator_name(logic);\n  let args = logic[op_name]; // operands\n\n  // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n  if (!isArray(args)) {\n    args = [args];\n  }\n\n  const operator = operators[op_name];\n  if (!operator) {\n    throw new Error(`Unrecognized operation ${op_name}`);\n  }\n\n  return operator(apply, data, args);\n}\n","import createJsonLogicApply from './createJsonLogicApply';\n\nimport isArray from './helpers/isArray';\nimport is_logic from './helpers/is_logic';\nimport truthy from './helpers/truthy';\nimport get_operator_name from './helpers/get_operator_name';\nimport get_values from './helpers/get_values';\nimport uses_data from './helpers/uses_data';\nimport rule_like from './helpers/rule_like';\n\nimport * as op from './operators';\n\n\nconst defaultOperators = {\n  /* eslint-disable */\n  '+': op.add,\n  'all': op.all,\n  'and': op.and,\n  'cat': op.cat,\n  '/': op.divide,\n  '==': op.equal,\n  'filter': op.filter,\n  '>': op.greater,\n  '>=': op.greaterEqual,\n  '?:': op.if,\n  'if': op.if,\n  'in': op.in,\n  '<': op.less,\n  '<=': op.lessEqual,\n  'log': op.log,\n  'map': op.map,\n  'max': op.max,\n  'merge': op.merge,\n  'method': op.method,\n  'min': op.min,\n  'missing': op.missing,\n  'missing_some': op.missing_some,\n  '%': op.modulo,\n  '*': op.multiply,\n  'none': op.none,\n  '!': op.not,\n  '!=': op.notEqual,\n  '!!': op.notnot,\n  'or': op.or,\n  'reduce': op.reduce,\n  'some': op.some,\n  '===': op.strictEqual,\n  '!==': op.strictNotEqual,\n  'substr': op.substr,\n  '-': op.subtract,\n  'var': op.var,\n  /* eslint-enable */\n};\n\nfunction add_operation(name, operator) {\n  if (isArray(name)) {\n    name.forEach(key => add_operation(key, operator));\n    return;\n  }\n  if (typeof operator === 'function') {\n    // `operator` is a function(args...)\n    // need to rework as function(apply, data, raw_args)\n    defaultOperators[name] = (apply, data, raw_args) => {\n      const args = raw_args.map(raw_arg => apply(raw_arg, data));\n      return operator(...args);\n    };\n  } else if (typeof operator === 'object') {\n    Object.getOwnPropertyNames(operator).forEach(prop_name => {\n      add_operation(`${name}.${prop_name}`, operator[prop_name]);\n    });\n  }\n}\n\nfunction rm_operation(name) {\n  if (isArray(name)) {\n    name.forEach(key => rm_operation(key));\n    return;\n  }\n  delete defaultOperators[name];\n}\n\n// export original public API:\nexport default {\n  apply: createJsonLogicApply(defaultOperators),\n  add_operation,\n  rm_operation,\n\n  is_logic,\n  truthy,\n  get_operator_name,\n  get_values,\n  uses_data,\n  rule_like,\n};\n","import isArray from './isArray';\nimport is_logic from './is_logic';\nimport get_operator_name from './get_operator_name';\nimport arrayUnique from './arrayUnique';\n\nfunction uses_data(logic) {\n  const collection = [];\n\n  if (is_logic(logic)) {\n    const op = get_operator_name(logic);\n    let values = logic[op];\n\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    if (op === 'var') {\n      // This doesn't cover the case where the arg to var is itself a rule.\n      collection.push(values[0]);\n    } else {\n      // Recursion!\n      values.forEach(val => {\n        collection.push(...uses_data(val));\n      });\n    }\n  }\n\n  return arrayUnique(collection);\n}\n\nexport default uses_data;\n","/**\n * Return an array that contains no duplicates (original not modified)\n * @param  {array} array   Original reference array\n * @return {array}         New array with no duplicates\n */\nfunction arrayUnique(array) {\n  const a = [];\n  for (let i = 0, l = array.length; i < l; i++) {\n    if (a.indexOf(array[i]) === -1) {\n      a.push(array[i]);\n    }\n  }\n  return a;\n}\n\nexport default arrayUnique;\n"],"names":["arrayUnique"],"mappings":"y/BAEqB,CAAA,6lBCWM,CAAA,oiBCHH,CAAA,4ICRH,CAAA,sYCAA,CAAA,yaCUjB,CAAA,wgBCHiB,CAAA,4MC+CJ,CAAA,mFAOe,CAAA,iHAIiB,CAAA,0EAQhC,CAAA,wMCtDI,CAAA,2CChBrB,CAAA,4FDsBSA,CAAAA"}