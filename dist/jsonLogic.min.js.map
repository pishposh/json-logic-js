{"version":3,"file":"jsonLogic.min.js","sources":["../src/operators/add.js","../src/operators/filter.js","../src/operators/map.js","../src/operators/merge.js","../src/operators/multiply.js","../src/operators/reduce.js","../src/createJsonLogic.js","../src/helpers/uses_data.js","../src/helpers/arrayUnique.js"],"sourcesContent":["// export default function add(...args) {\nexport default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);\n}\n","import isArray from '../helpers/isArray';\nimport truthy from '../helpers/truthy';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n  // Return only the elements from the array in the first argument,\n  // that return truthy when passed to the logic in the second argument.\n  // For parity with JavaScript, reindex the returned array\n  return scopedData.filter(datum => truthy(apply(scopedLogic, datum)));\n}\n","import isArray from '../helpers/isArray';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n\n  return scopedData.map(datum => apply(scopedLogic, datum));\n}\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => a.concat(b), []);\n}\n","export default (apply, data, raw_args) => {\n  const args = apply(raw_args, data);\n  return args.reduce((a, b) => parseFloat(a) * parseFloat(b), 1);\n}\n","import isArray from '../helpers/isArray';\n\nexport default (apply, data, raw_args) => {\n  const scopedData = apply(raw_args[0], data);\n  const scopedLogic = raw_args[1];\n  const initial = typeof raw_args[2] !== 'undefined' ? raw_args[2] : null;\n\n  if (!isArray(scopedData)) {\n    return initial;\n  }\n\n  return scopedData.reduce(\n    (accumulator, current) => apply(scopedLogic, { current, accumulator }),\n    initial\n  );\n}\n","import isArray from './helpers/isArray';\nimport is_logic from './helpers/is_logic';\nimport get_operator_name from './helpers/get_operator_name';\n\nfunction createJsonLogic(operations = {}) {\n  function add_operation(name, operator) {\n    if (isArray(name)) {\n      name.forEach(key => add_operation(key, operator));\n      return;\n    }\n\n    if (typeof operator === 'function') {\n      // `operator` is a function(args...)\n      // need to rework as function(apply, data, raw_args)\n      operations[name] = (apply, data, raw_args) => {\n        const args = raw_args.map(raw_arg => apply(raw_arg, data));\n        return operator(...args);\n      };\n    } else if (typeof operator === 'object') {\n      Object.getOwnPropertyNames(operator).forEach(prop_name => {\n        add_operation(`${name}.${prop_name}`, operator[prop_name]);\n      });\n    }\n  }\n\n  function rm_operation(name) {\n    if (isArray(name)) {\n      name.forEach(key => rm_operation(key));\n      return;\n    }\n\n    delete operations[name];\n  }\n\n  function apply(logic, data) {\n    if (!data) data = {};\n\n    // Does this array contain logic? Only one way to find out.\n    if (isArray(logic)) {\n      return logic.map(l => apply(l, data));\n    }\n    // You've recursed to a primitive, stop!\n    if (!is_logic(logic)) {\n      return logic;\n    }\n\n    const op_name = get_operator_name(logic);\n    let args = logic[op_name]; // operands\n\n    // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n    if (!isArray(args)) {\n      args = [args];\n    }\n\n    const operator = operations[op_name];\n    if (!operator) {\n      throw new Error(`Unrecognized operation ${op_name}`);\n    }\n\n    return operator(apply, data, args);\n  }\n\n  return {\n    apply,\n    add_operation,\n    rm_operation,\n  };\n}\n\nexport default createJsonLogic;\n","import isArray from './isArray';\nimport is_logic from './is_logic';\nimport get_operator_name from './get_operator_name';\nimport arrayUnique from './arrayUnique';\n\nfunction uses_data(logic) {\n  const collection = [];\n\n  if (is_logic(logic)) {\n    const op = get_operator_name(logic);\n    let values = logic[op];\n\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    if (op === 'var') {\n      // This doesn't cover the case where the arg to var is itself a rule.\n      collection.push(values[0]);\n    } else {\n      // Recursion!\n      values.forEach(val => {\n        collection.push(...uses_data(val));\n      });\n    }\n  }\n\n  return arrayUnique(collection);\n}\n\nexport default uses_data;\n","/**\n * Return an array that contains no duplicates (original not modified)\n * @param  {array} array   Original reference array\n * @return {array}         New array with no duplicates\n */\nfunction arrayUnique(array) {\n  const a = [];\n  for (let i = 0, l = array.length; i < l; i++) {\n    if (a.indexOf(array[i]) === -1) {\n      a.push(array[i]);\n    }\n  }\n  return a;\n}\n\nexport default arrayUnique;\n"],"names":["arrayUnique"],"mappings":"mgCAGqB,CAAA,6lBCUM,CAAA,4iBCHH,CAAA,4ICRH,CAAA,sYCAA,CAAA,yaCUjB,CAAA,sgBC2BmB,CAAA,2MAhCJ,CAAA,mFAQe,CAAA,iHAIiB,CAAA,0EAQhC,CAAA,sNCNE,CAAA,2CChBrB,CAAA,4FDsBSA,CAAAA"}